# 输入URL到浏览器界面

URL主要由协议、主机、端口、路径、查询参数、锚点6部分组成

输入URL到页面经历：

- DNS解析
- 发起TCP连接
- 发送HTTP请求
- 服务器处理请求并返回
- 浏览器解析渲染页面
- 连接结束。

## 第一部分：DNS解析

进行url解析，根据dns系统进行ip查找

- url解析：网络标准规定了URL只能是字母和数字，还有一些其它特殊符(_ ( ) ; : @ & = + $ , / ? # [ ])，如果不转义会出现歧义,比如www.baodu.com/key=value,假如value中有 = ，就区分不了。解决**utf-8、ASCII编码**,不同浏览器用的不一样。
- DNS解析查找：输入url后，首先在本地的域名服务器中查找，没有就到根域名服务器查找
- DNS缓存：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存
- DNS优化： 在html页面头部写入dns缓存地址

​	`<meta http-equiv="x-dns-prefetch-control" content="on" /> `

`<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />`

## 第二部分：TCP/IP连接(三次握手)

OSI模型：物理层 ——数据链路层——网络层(IP协议)——传输层(TCP/UDP协议)——会话层——表示层——应用层(HTTP协议)

第一次握手：主机A发送位码为SYN＝1的TCP包给服务器，并且随机产生一个作为确认号（这是tcp包的一部分），主机B收到SYN码后知道A要求建立连接;

第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；

第三握手：主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

为什么不能二次？因为第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接

## 第三部分： HTTP请求

http协议：超文本传输协议，可靠传输，无状态

常见的请求方法： GET`,`POST`, `PUT`, `DELETE

get和post区别：

- GET一般用来获取，post一般用来提交
- GET在浏览器回退时是无害的，而POST会再次提交请求
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
- GET可被收藏为书签，post不可以
- GET能被缓存、POST不能被缓存。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中

HTTP:缓存

## 第四部分： 服务器处理请求并返回HTTP报文

HTTP报文也分成三份，**状态码** ，**响应报头**和**响应报文体(html、css、js文件)**

状态码：

- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。

常见的状态码有:

- 200请求成功
- 204成功处理了请求，但没有返回内容
- 301永久重定向
- 302临时重定向
- 400错误请求
- 404请求不到资源
- 500服务器内部错误

## 第五部分： 浏览器渲染页面

1. 构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
2. 构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
3. 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
4. 构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；
5. 渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。
6. 布局（layout，回流）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
7. 绘制（painting，重绘）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式；







