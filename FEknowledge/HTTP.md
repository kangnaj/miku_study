# HTTP

http协议：超文本传输协议，可靠传输，无状态

## HTTP报文结构

HTTP 结构，是`header + body`的结构，具体而言:

```
起始行 + 头部 + 空行 + 实体
```

http报文分为 `请求报文`和`响应报文`

### 起始行

对于请求报文来说，起始行类似：

```
GET /home HTTP/1.1
```

对于响应报文，起始行类似：

```
HTTP/1.1 200 OK
```

响应报文的起始行也叫状态行，有**http版本、状态码和原因**三部分组成

### 头部

请求头和响应头

### 空行

用来区分开`头部`和`实体`。

### 实体

请求报文对应`请求体`, 响应报文对应`响应体`

## HTTP的请求方式

- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

### GET和POST区别

- GET在浏览器回退是无影响的，而POST会在提交请求
- GET请求参数会被保留在浏览器历史里，而POST中的参数不会被保留
- GET可被收藏为书签，POST不可以
- GET 请求会被浏览器主动缓存下来，而 POST 默认不会
- GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中

get拼接url,post传body，get限制字符串长度吗！ 请求缓存：GET 会被缓存，而post不会 原因就是get是url的请求，没有请求体！上哪缓存去！ 收藏书签：GET可以，而POST不能 原因还是因为url可以收藏，请求体上哪收藏！ 保留浏览器历史记录：GET可以，而POST不能 原因还是因为get的url请求！ 用处：get常用于取回数据，post用于提交数据 原因是get的url传输不管怎么说，都是有字符数限制的！你用get提交个试试！如果字符串长度不超，一样能提交数据！ 安全性：post比get安全 还是因为post是请求体，不会在url上被劫持！ 请求参数：querystring 是url的一部分get、post都可以带上。 get的querystring（仅支持urlencode编码），post的参数是放在body（支持多种编码） 这一点知道了其它的不就明白一大堆了！ 请求参数长度限制：get请求长度最多1024kb，post对请求数据没有限制

## HTTP优缺点

### HTTP特点

**「灵活可扩展」**。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。

**「请求-应答模式」**，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。

**「可靠传输」**，HTTP是基于TCP/IP，因此把这一特性继承了下来。

**「无状态」**，这个分场景回答即可。

### HTTP缺点

**「无状态」**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等

**「明文传输」**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。HTTP的报文信息暴露给了外界。

**「队头阻塞」**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

## 理解URI

URI：统一资源标识符，作用是用来区分互联网上的不同的资源

URI包含URN和URL,URI编码只能用ASCII

## HTTP状态码

状态码：

2xx：成功–表示请求已被成功接收、理解、接受。

3xx：重定向–要完成请求必须进行更进一步的操作。

4xx：客户端错误–请求有语法错误或请求无法实现。

5xx：服务器端错误–服务器未能实现合法的请求。

常见的状态码有:

200请求成功

204成功处理了请求，但没有返回内容

301永久重定向

302临时重定向

400错误请求

404请求不到资源

500服务器内部错误

## HTTP1缺陷

HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，就会造成队头阻塞

在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性

## HTTP2改进

二进制分帧

头部压缩

多路复用

服务器推送

## ☆HTTP缓存

### 缓存的优点

- 缓解服务器压力
- 提升性能
- 减少宽带消耗

### Web缓存种类

数据库缓存

CDN缓存

代理服务器缓存

浏览器缓存

浏览器缓存就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘去区作为数据传输的缓冲区，用这个缓存区来暂时保存用户访问过的信息

### 浏览缓存过程： 强缓存，协商缓存

#### 强缓存

强缓存是在当我们访问URL的时候，不会向服务器发送请求，直接从缓存中读取资源，会返回200的状态

也就是`HTTP/1.0`时期，使用的是**Expires**，而`HTTP/1.1`使用的是**Cache-Control**。

第一次进入页面，请求服务器，然后服务器响应，浏览器根据响应头来判断是否进行缓存，如果响应头中有Expires和Cache-Control

表示这是强缓存，浏览器会把资源缓存在memory cache 或 dist cache

第二次请求，浏览器会判断请求参数，如果符合强缓存条件就直接返回状态码200，从本地缓存中拿数据

expires: 表示过期时间，存在服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据

```
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

Cache-Control:采用过期时长来控制缓存   ,优先级更高（如果cache-control,会取expires的值，判断是否过期）

```
Cache-Control:max-age=3600/no-cache
```

会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存

主要取值：

**public**: 客户端和代理服务器都可以缓存

**private**： 这种情况就是只有浏览器能缓存

**no-cache**: 跳过当前的强缓存，直接进入`协商缓存阶段`

**no-store**：非常粗暴，不进行任何形式的缓存

**max-age**：缓存保质期。

#### 协商缓存

协商缓存就是强缓存失效后，浏览器在请求头中携带缓存标识向服务器发请求，服务根据这个标识来决定是否使用缓存，这个缓存就是协商缓存

缓存标识：Last-Modified和ETag （ETag会优于Last-Modified）

**Last-Modified**: 最后修改时间（能够感知的单位时间是秒），第一次请求后，服务器会在响应头加上这个字段

浏览器接收后，如果再发请求，会在请求头携带**If-Modified-Since**,就是上次服务器请求返回的最后修改时间(Last-Modified),根据这个值与该资源在服务器的最后修改时间做比较，这个值小于服务器最后修改时间，则重新返回资源，状态码200，否则返回304，告诉浏览器直接用缓存

**ETag**: 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变，服务器通过响应头把这个值给浏览器

浏览器接收ETag后,会在下次请求是，将这个值作为If-None-Match这个字段的内容，请求头会携带这个值，服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对

#### 启发式缓存

只有在服务端没有返回明确的缓存策略时才会激活启发式缓存策略

通常是 `Date` 和 `Last-Modified` 。此时，缓存有效期一般取两者差值的 10%

### 缓存位置

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

#### Service Worker:

是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用Service Worker 传输协议必须是HTTPS

#### Memory Cache 和 Disk Cache

**Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了

**Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长

#### Push Cache

即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容

from disk cache和from memory cache:

1、先查找内存，如果内存中存在，从内存中加载； 

2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载； 

3、如果硬盘中未查找到，那就进行网络请求； 

4、加载到的资源缓存到硬盘和内存；

## HTTPS

超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS)

HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包

### SSL/TLS协议

HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：`散列函数` 、`对称加密`和`非对称加密`，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性



## http1.1和http2.0有什么区别？

### http1.1

- 引入了持久链接，即TCP默认不关闭，可以被多个请求复用
- 引入管道机制，一个TCP连接，可以同时发送多个请求
- 新增了一些缓存的字段
- 新增了一些方法，PUT、DELETE、OPTIONS、PATCH
- 支持断点续传，通过请求头字段Rang来实现

### http2.0

- 头部压缩
- 多路复用
- 二进制传输，头信息和数据体都是二进制
- 请求优先级， 设置数据帧的优先级，让服务器优先处理
- 服务器主动推送消息

## options 请求

options 请求就是预检请求

用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法

这是因为在跨域的情况下，在浏览器发起"复杂请求"时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求

可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求
